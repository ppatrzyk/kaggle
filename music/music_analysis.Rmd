---
title: "Music Production Across the World"
author: "Piotr Patrzyk"
output: 
  html_document:
    keep_md: true
---

TODO: artist name duplicites stats before cleaning step

## Introduction

An exploratory analysis of data on the popularity of musical artists. Where do the most polular artists come from? Which musical genres are the most popular? Are musical genres tied to specific countries? These are the questions investigated in this kernel.

## Preparing data

First I read and prepare the data. This includes:

- cleaning duplicates in artists,
- establishing country of origin,
- establishing single genre from tags.

```{r dataload, echo=FALSE}
library(data.table)
library(ggplot2)
library(leaflet)
library(geojsonio)

lfm <- fread('artists.csv', encoding = 'UTF-8', na.strings = '')
```

Due to the fact that last.fm does dot disambiguate between different artists that have the same name (see dataset description), dataset contains some artists with duplicated listeners/scrobbles count, coming from the aggregate profile. For example:

```{r}
lfm[
  artist_lastfm == 'Phoenix', 
  .(artist_mb, artist_lastfm, country_mb, country_lastfm, listeners_lastfm, scrobbles_lastfm)
]
```

I collapse ambiguous artists (`ambiguous_artist == TRUE`) into one row per artist name.

```{r collapseartists, echo=TRUE}
lfm[, mbid := NULL]
fix <- lfm[ambiguous_artist == TRUE, ]
lfm <- lfm[ambiguous_artist == FALSE, ]

fix <- fix[,
  .(
    artist_mb = paste(unique(na.omit(artist_mb)), collapse = '; '),
    country_mb = paste(unique(na.omit(country_mb)), collapse = '; '),
    country_lastfm = paste(unique(na.omit(country_lastfm)), collapse = '; '),
    tags_mb = paste(na.omit(tags_mb), collapse = '; '),
    tags_lastfm = paste(unique(na.omit(tags_lastfm)), collapse = '; '),
    listeners_lastfm = max(listeners_lastfm, na.rm = TRUE),
    scrobbles_lastfm = max(scrobbles_lastfm, na.rm = TRUE),
    ambiguous_artist = TRUE
  ),
  by = artist_lastfm
]

lfm <- rbindlist(list(lfm, fix), fill = TRUE)
rm(fix)
```

Next I identify single country an artist comes from. The dataset contains conflicting information about artists' origin. Sometimes there is a legitimate ambiguity in what should be chosen, in other cases there is an incorrect information due to factual errors or artist duplicites. In either case, these need to be unified. Examples of problematic data:

```{r countryexample, echo=TRUE}
lfm[
  artist_lastfm %in% c('Rihanna', 'System of a Down', 'Shakira'),
  .(artist_mb, country_mb, country_lastfm, listeners_lastfm)
]
```

The approach is the following:

- if there is only one MusicBrainz country and it is contained in last.fm tags, this one is chosen,
- else if there is only one country in last.fm tags, this one is chosen,
- else if there is only one country in MusicBrainz tags, this one is chosen,
- to resolve conflicts in remaining entries, the most frequest country in last.fm tags is chosen.

Note, as there is no way to automatically verify whether multiple countries in last.fm tags relate to one artist or multiple artists sharing one profile, in the fourth step we might end up with an overestimate of artist popularity (only one end up being chosen, but their scobble count come from a shared profile).

```{r countryfix, echo=TRUE}
# unify countries
lfm[, country := NA_character_]
lfm[
  !grepl(';', country_mb) & (mapply(grepl, country_mb, country_lastfm) | is.na(country_lastfm)),
  country := country_mb
]
lfm[
  is.na(country) & !grepl(';', country_lastfm),
  country := country_lastfm
]
lfm[
  is.na(country) & !grepl(';', country_mb),
  country := country_mb
]

countries <- fread('https://raw.githubusercontent.com/ppatrzyk/kaggle/master/music/countries.csv', encoding = 'UTF-8')
patterns <- countries[,
  .(pattern = paste0(sprintf('[ ;^]%s[ ;$]', adjectival), collapse = '|')), 
  by = country
]
patterns[, pattern := paste(pattern, sprintf('[ ;^]%s[ ;$]', country), sep = '|')]
rm(countries)

first_match <- function(tags) {
  match <- patterns[,
    regexpr(pattern, tags, ignore.case = TRUE), 
    by = country
  ][V1 != -1, ][order(V1), ][1L, country]
  return(match)
}

lfm[
  is.na(country) & !is.na(country_lastfm),
  country := sapply(tags_lastfm, first_match, USE.NAMES = FALSE)
]

print('Example fo resolving conflicts:')
lfm[
  artist_lastfm %in% c('Arkona', 'Garbage', 'Ikon'),
  .(artist_lastfm, country_mb, country_lastfm, country)
]

```

In the next step I assign genre to each artist. This step requires investigating all tags and identifying unique genres in them. This requires some aggregation over different spelling, qualifiers, etc. First I read all tags to a separate data.table.

```{r tagexploration, echo=TRUE}
tags_lfm <- as.data.table(table(tolower(
  lfm[
    !is.na(tags_lastfm),
    unlist(strsplit(tags_lastfm, split = '; '))
  ]
)))[order(N, decreasing = TRUE), ]

print('20 most frequent:')
head(tags_lfm, 20)
print(paste('Unique tags (case insensitive):', tags_lfm[, .N]))
print(paste0('Tags used only once: ', round(100 * (tags_lfm[N == 1, .N] / tags_lfm[, .N]), 2), '%'))
print(paste0('Used at least 10 times: ', tags_lfm[N >= 10, .N], ' (', round(100 * (tags_lfm[N >= 10, .N] / tags_lfm[, .N]), 2), '%)'))
```

A quick glance at tags reveals that a lot of information is not related to the genre of music (e.g., *(fe)male vocalists*, *seen live*, *under 2000 listeners*, etc.) and that there is a lot of 'compound' tags -- instead of tagging a band with tags *norwegian* **and** *black metal*, people assign tags such as *true oldschool norwegian black metal* (trve, tru, troo, tr00 are also observed).

```{r blackmetalexample, echo=TRUE}
print(paste("Unique \'black metal\' tags:", tags_lfm[grepl('black.*metal', V1), .N]))
head(tags_lfm[grepl('black.*metal', V1), ], 10)
```

The approach to establishing a single genre is the following:

- for each artist, get a rank of tags,
- pick the most popular tag,
- if the picked tag is not related to genre (see above), iteratively replace by next tag in the rank,
- aggragate tags

```{r genreaggregation, echo=TRUE}
filter_pattern <- paste(
  patterns[, paste(pattern, collapse = '|')],
  '^all$', "^\\d+[s]?$", "live", "male", "europe", "listen", "eurovision", "^world$", "balkan", "participant", "gorgeous", "factor", "shqip",
  "singer", "songwriter", "soundtrack", "beautiful", "awesome", "scandinav", "streamable", "duo", "radio", "century",
  "recording", "creative", "espa", "francai", "deutsch", "portugu", "eesti", "azeri", "svenskt", "^love$", "cover",
  "funny", "humo", "super", "porn", "boobs", "science", "muzika", "muzyka", "podcast", "test", "shit", "festival", "album",
  "iskelma", "comedy", "composer", "dansk", "siberia", "norsk", "polsk", "^sex$", "epic", "parody",
  "caucasia", "albani", "suomi", "duet", "prank", "spotify",
  "^music$", "5432fun", "easy listening", "schlager", "oldies", "^idol$", "liedermacher", "^everything$", "^nordic$", "^amazing$",
  sep = '|'
)
lfm[
  !is.na(tags_lastfm),
  paste0('tag', 1:10) := tstrsplit(tolower(tags_lastfm), '; ', keep = 1:10)
]
lfm[!is.na(tags_lastfm), genre := tag1]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag2]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag3]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag4]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag5]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag6]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag7]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag8]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag9]
lfm[!is.na(tags_lastfm) & grepl(filter_pattern, genre, ignore.case = TRUE), genre := tag10]
lfm[, paste0('tag', 1:10) := NULL]
# TODO when na, fall back to musicbrainz tag, rewrite with flag-setting (?)
```


## Popularity distribution

very few artists generate the majority of world's scrobbles, while the vast majority of artists have a very small number of listeners and scrobbles.

## Geography of music production

## Conclusion

Last.fm users do not constitute representative sample of world's music listeners. Hence, the number of scrobbles is an imperfect proxy to the number of times given artist has been listened to.