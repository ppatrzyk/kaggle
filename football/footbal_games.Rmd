---
title: "Head-to-head: An interactive d3 map"
author: "Piotr Patrzyk"
output: 
  html_document:
    keep_md: false
---

```{r setup, include=FALSE}
library(data.table)
library(r2d3)
library(jsonlite)

knitr::opts_chunk$set(
  echo = FALSE,
  out.width = '100%'
)
```

```{r customcss, results="asis"}
cat("
<style>
svg {
  display: block;
  margin: auto;
}

.tooltip {
  position: absolute;
  text-align: center;
  padding-left: 10px;
  padding-right: 10px;
  padding-top: 3px;
  padding-bottom: 3px;
  background: #d4d6d8;
  border: 0px;
  border-radius: 8px;
  pointer-events: none;
}

.country-border {
  stroke: white;
  stroke-width: 0.5;
}
</style>
")
```

# Introduction

In this kernel I visualize head-to-head balances in international footbal games. For any given team, you can quickly look up:

- what other teams have they played against,
- with whom do they usually win or lose.

## Dataset

```{r dataload}
games <- fread('results.csv', encoding = 'UTF-8')
```

The dataset contains `r games[, .N]` matches played by `r games[, uniqueN(c(home_team, away_team))]` different teams. The coverage is quite good as there is even information of games such as:

```{r tibetexample}
games[
  home_team == 'Greenland' & away_team == 'Tibet', 
  .(date, home_team, away_team, home_score, away_score, city)
]
```

## Data aggregation

The dataset is aggregated to obtain head-to-head summary (#wins, #draws, #losses) for all team pairs in the dataset.

```{r getresults}
games[, goal_diff := home_score - away_score]
unique_teams <- games[, unique(c(home_team, away_team))]
# outcomes_list is in r2d3-friendly format, headtoheadfor analysis in R
outcomes_list <- headtohead <- replicate(length(unique_teams), data.table())
names(outcomes_list) <- unique_teams
for (i in 1:length(unique_teams)) {
  current_team <- unique_teams[i]
  current_games <- games[home_team == current_team | away_team == current_team, ]
  current_games[, location_home := (home_team == current_team)]
  current_games[, rival := ifelse(location_home, away_team, home_team)]
  current_games[location_home == FALSE, goal_diff := -goal_diff]
  outcomes <- current_games[,
    .(
      team = current_team,
      win = sum(goal_diff > 0),
      draw = sum(goal_diff == 0),
      loss = sum(goal_diff < 0),
      total = .N
    ),
    by = rival
  ]
  outcomes[, difference := (win - loss)]
  outcomes[, metric := round(difference / total, 2)]
  tooltip <- outcomes[, sprintf('%s vs. %s<br>W:%s D:%s L:%s', current_team, rival, win, draw ,loss)]
  metric <- outcomes[, metric]
  total <- outcomes[, total]
  names(metric) <- names(tooltip) <- names(total) <- outcomes[, rival]
  headtohead[[i]] <- outcomes[, .(team, rival, win, draw, loss, difference, total, metric)]
  outcomes_list[[i]] <- list(
    metric = as.list(metric),
    total = as.list(total),
    tooltip = as.list(tooltip)
  )
}
headtohead <- rbindlist(headtohead)
# toJSON(outcomes_list, auto_unbox = TRUE)
```

Aggregated data has `r headtohead[, .N]` rows. As the summary is generated both ways, e.g.:

```{r engswissex}
headtohead[
  (team == 'England' & rival == 'Switzerland') | (rival == 'England' & team == 'Switzerland'),
  .(team, rival, win, draw, loss)
]
```

This means that there are `r headtohead[, .N/2]` unique pairs. Given that there are `r paste0('choose(294, 2)', ' = ', choose(games[, uniqueN(c(home_team, away_team))], 2))` possible pairs, this means that only `r paste0(round(100 * headtohead[, .N/2] / choose(games[, uniqueN(c(home_team, away_team))], 2), 2), "%")` of possible matches actually took place.

Top 10 most often meeting teams:

```{r totalmax}
headtohead[order(-total), ][seq(1, 20, 2), .(team, rival, win, draw, loss, total)]
```

todo headtohead: 1 historical games hungary 2 transitivity find example

The metric that is displayed on the map below is obtained by using the formula: 

$$
metric = \frac{won-lost}{total\_played}
$$
The metric ranges from -1 (all games lost against given rival) to 1 (all games won). In case of even balance it equals to 0.

For example:

```{r scotland}
headtohead[team == 'Scotland' & rival == 'Wales', ]
```

# Map

In order to **change country** for which head-to-head stats are displayed **click on it** on the map.

```{d3 map, data=outcomes_list}
var margin = {top: 25, right: 25, bottom: 25, left: 25};
var map_default_scale = 175.295;
var map_tooltip = null;
var map_json = null;
var color_scale = d3.scaleSequential(d3.interpolatePiYG);
var missing_color = "#000000";

var map = svg
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .attr("class", "border")
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
  .attr("id", "mapgroup");

function render_map(initial_country){
  
  map.append("text")
    .attr("text-anchor", "end")
    .attr("x", 0)
    .attr("y", 0)
    .text(initial_country);
  
  color_scale.domain([-1, 1]);
  
  var projection = d3.geoNaturalEarth1()
    .translate([width/2, height/2])
    .scale(map_default_scale);

  var path = d3.geoPath().projection(projection);
  
  map_tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);  
    
  map.append("rect")
    .attr("x", 0).attr("y", 0)
    .attr("width", width).attr("height", height)
    .attr('fill', '#cfeff9')
    .attr("opacity", 0);
  
  map.selectAll("path")
    .data(map_json.features)
    .enter()
    .append("path")
    .attr("d", path)
    .attr("class", "country-border")
    .style("fill", function(d) {
      var country = d.properties[initial_country];
      if (country) {
        return color_scale(country.metric);
      } else {
        return missing_color;
      }
    })
    .on("mouseover", function(d) {
      var content = d.properties[initial_country];
      if (typeof content !== 'undefined'){
        map_tooltip.transition().duration(200).style("opacity", 0.9);
        map_tooltip.html(content.tooltip)
          .style("left", (d3.event.pageX) + "px")
          .style("top", (d3.event.pageY - 28) + "px");
      }
    })
    .on("mouseout", function(d) {
      map_tooltip.transition().duration(500).style("opacity", 0);
    })
    .on("click", function(d) {
      update_map(d.properties.admin);
    });
    
  var zooming = function(d) {
    var offset = [d3.event.transform.x, d3.event.transform.y];
    var scale_update = (d3.event.transform.k * map_default_scale);
    projection.translate(offset)
      .scale(scale_update);
    map.selectAll("path")
      .attr("d", path);
  };
  
  var zoom_handler = d3.zoom()
    .scaleExtent([1, 20])
    .translateExtent([
      [-width/2+margin.left, -height/2+margin.top],
      [width/2+margin.right, height/2+margin.bottom]
    ])
    .on("zoom", zooming);
  
  map
    .call(zoom_handler)
    .call(zoom_handler.transform, function(){
      return d3.zoomIdentity.translate(width/2, height/2);
    })
    .on("wheel", function() {
      d3.event.preventDefault();
  });
};

function update_map(new_country){
  map.selectAll("path")
    .style("fill", function(d) {
      var country = d.properties[new_country];
      if (country) {
        return color_scale(country.metric);
      } else {
        return missing_color;
      }
    })
    .on("mouseover", function(d) {
      var content = d.properties[new_country];
      if (typeof content !== 'undefined'){
        map_tooltip.transition().duration(200).style("opacity", 0.9);
        map_tooltip.html(content.tooltip)
          .style("left", (d3.event.pageX) + "px")
          .style("top", (d3.event.pageY - 28) + "px");
      }
    })
    .on("mouseout", function(d) {
      map_tooltip.transition().duration(500).style("opacity", 0);
    })
    .on("click", function(d) {
      console.log(d.properties.admin);
      update_map(d.properties.admin);
    });
};
  
d3.json('https://raw.githubusercontent.com/ppatrzyk/kaggle/master/football/map.json')
  .then(function(json){
    map_json = json;
    for (var country in data) {
      var metric = data[country]['metric'];
      var tooltip = data[country]['tooltip'];
      var total = data[country]['total'];
      // todo set scale
      for (var key in metric) {
        if (metric.hasOwnProperty(key)) {
          var current_metric = metric[key];
          var current_tooltip = tooltip[key];
          var current_total = total[key];
          for (var i = 0; i < map_json.features.length; i++) {
            var current_country = map_json.features[i].properties.admin;
            if (key == current_country) {
              map_json.features[i].properties[country] = {}
              map_json.features[i].properties[country].metric = current_metric;
              map_json.features[i].properties[country].tooltip = current_tooltip;
              map_json.features[i].properties[country].total = current_total;
              break;
            }
          }
        }
      }
    }
    render_map('Poland');
  });

```

